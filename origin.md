###### 起源
* 共同学习和探讨js，是封装这个框架一个最重要的原因
* 脚本：在我的理解，90%的脚本无非是围绕着click进行的，对于app类，主要是控件的查找，对于游戏类，无非是找图找色（这里只讨论模拟按键类）
* autojs相对于其他平台，在游戏方面的操作相对较弱，对于一大部分想做游戏的不知道怎么入门，可能一个多点找色就折腾个大半天，更不要考虑多分辨率兼容了

###### 从实际需求出发
* 基于autojs提供的api，开发起来依然要写很多代码逻辑，控件有没有找到？等等，一堆的if else 判断。相信很多人都有自己封装的一套api。没有的话，那你的代码量可能是别人的几倍。
* 对于界面的跳转，是需要时间的，在不同性能的设备，时间也不一样，那么在找控件/多点找色，我这个延时需要多久？代码10行就要写一行sleep()?,整个脚本充斥着大量的非业务性代码，维护性差，阅读困难
* 现在很多都封号严格，你一个坐标点击n次，不封你封谁。所以在某些方面，需要坐标随机、时间随机。代码量再次增加，怎样才能省力省心做到这些？
* 对于游戏类的找图找色，想要兼容多个分辨率？这个很多人简直无从下手，相信就是大佬也要花费时间才折腾出来。
* 现在看看自己写的脚本，数一数有多少个if/ else/ sleep?。看起来逻辑有没有一目了然？

`当你遇到上述的问题而难以解决时，那么本框架为你排忧解难`

##### 我们先来看个很简单示例
```js
// 实现功能：点击a 按钮进入a页面，然后在a页面点击b按钮，进入b页面，暂时假定通过按钮的id来选择
//框架实现
var $ = require("./mQuery.js");
$("#a").click().$("#b").click();



//类似于原生的实现(非全等) 
var aBtn = id("a").findOne();
aBtn.click();
var bBtn = id("b").findOne();
bBtn.click();

```
* 看完上面的例子，可能还没感受到什么特别之处。这里看似实现的功能非常简单。但包含诸多细节。
1. 按钮是否是cliabled 的，如果不是那么原生的实现还要做判断，给他以坐标的方式点击。
2. 可以看到上面用的是findOne 的阻塞函数，如果a按钮点击不成功，那么查找b按钮永远阻塞在这里了。不然换用findOnce，或者给一个超时时间，然后还得判断b按钮有没找到，再进行点击（注：页面跳转页需要时间），显然，原生实现起来完整的功能，比上述代码要多得多。
3. 而框架封装提供的是简单的调用方式，以上细节都在内部处理好，包括是以控件点击还是坐标点击，点击的位置是否需要随机，点击后是否需要随机延迟，等等，只需要全局性声明一下配置即可，当然，框架已经默认了一套配置。后面教程会逐一为你展开。
4. 以上可以看到框架代码以链式调用的方式，
    那么和这种有什么区别呢：$("#a").click();  $("#b").click();
    区别就在于，前者：如果a按钮没有找到或者点击a按钮不成功，那么后面的操作会直接跳过。
    而后者如果点击a按钮不成功，依然会继续找b按钮
5. 这个例子只是最简单的，在实际的开发中，会遇到更多更复杂的逻辑，框架的到来将为你优化大量的逻辑。

###### `总而言之：在脚本编写的过程，总要写一堆的繁杂逻辑。而mQuery正为此诞生。`